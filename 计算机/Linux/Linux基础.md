# 第一次作业（陈一鸣）

## 一、虚拟机（vmware）

### 对vmware的重新认识

- 通过ssh命令，通过网络远程连接服务器，进行部署操作，vmware+linux。

- vwmare不影响宿主机。

- 桥接网络的认知：在你当前网络环境下，再分配一个ip地址，桥接就是让虚拟机和宿主机处于同一个局域网段。

- 对NAT（使用网络地址转换）的认知：NAT就是在你的网络环境下，在生成一个虚拟局域网，和宿主机不是同一个网段的。

- 对（仅主机模式网络）的认知：虚拟机就是单机模式，无法与他人通信。

- **网络连接方式** 

  | 连接方式 | 连接网卡     | 是否能连接本机 | 是否能连接局域网 | 是否能连接公网 |
  | -------- | ------------ | -------------- | ---------------- | -------------- |
  | 桥接     | 本地真实网卡 | 可以           | 可以             | 可以           |
  | NAT      | VMnet8       | 可以           | 不能             | 可以           |
  | 仅主机   | VMnet1       | 可以           | 不能             | 不能           |

### 安装centos图形界面

![](D:\桑梓\24寒假作业\屏幕截图(461).png)

- ### linux机器的默认7个终端

  按下ctrl+alt+f1~f7表示7个终端，也就是7个屏幕

  ctrl+alt+f2进入纯命令行界面

  ctrl+alt+f1返回图形界面

  ![](D:\桑梓\24寒假作业\image-20240117151106490.png)

  #### linux目录结构

  | 目录名            | 目录的作用                                                   |
  | ----------------- | ------------------------------------------------------------ |
  | /bin/             | 存放系统命令的目录，普通用户和超级用户都可以执行，是/usr/bin/目录的软链接 |
  | /sbin/            | 存放系统命令的目录，只有超级用户可以执行，是/ust/sbin/目录的软链接 |
  | /usr/bin/         | 存放系统命令的目录，普通目录和超级用户都可以执行             |
  | /usr/sbin/        | 存放系统命令的目录，只有超级用户可以执行                     |
  | /boot/            | 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序文件等 |
  | /dev/             | 设置文件保存位置                                             |
  | /etc/             | 配置文件保存位置，系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 |
  | /home/            | 普通用户的家目录，创建用户时，每个用户要有一个默认登入和保护自己数据的位置，就是用户的家目录。所以普通用户的宿主目录是在/home/下建立一个和用户名相同的目录买入用户user1的家目录就是/home/user1/ |
  | /lib/             | 系统调用的函数库的保存位置，是/usr/lib/的软链接              |
  | /lib-64/          | 64位函数库保存位置，是/usr/lib64/的软链接                    |
  | /lost+found/      | 当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里，当系统启动过程中，fsck工具会检查这里，并恢复已经损坏的文件系统。这个目录只有在每个分区中出现，例如/lost+found/就是根分区的备份恢复目录。/boot/lost+found/就是/boot分区的备份恢复目录 |
  | /media/           | 挂载目录，系统建议是用来挂载媒体设备的，如软盘和光盘（一般不用） |
  | /misc/            | 挂载目录，新系统建议用来挂载NFS服务的共享目录（一般不用）    |
  | /mnt/             | 挂载目录，早期linux中只有这一挂载目录，并没有细分。现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘和其他操作系统的分区（就是在该目录下建立子目录，子目录再来挂载不同的东西） |
  | /opt/             | 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。（不过习惯上不使用该目录，习惯把软件装到/usr/local/目录中） |
  | /proc/            | 虚拟文件系统，该目录中的数据并不保存在硬盘上，而是保存到内存中，主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的。/proc/net是保存网络协议信息的...... |
  | /sys/             | 虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息 |
  | /root/            | root的宿主目录。普通用户宿主目录在/home下，root宿主目录直接在"/"下 |
  | /run/             | 系统运行是产生的数据，如ssid，pid等相关数据。/var/run/是此目录的软链接 |
  | /srv/             | 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 |
  | /tmp/             | 临时目录。系统存放临时文件的目录，在该目录下，所以用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空 |
  | /selinux/         | linux的一个增强安全组建的一个保存位置， 用来限制root的权限   |
  | /usr/             | 系统软件资源目录。usr不是user的缩写，而是“UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里 |
  | /usr/lib/         | 应用程序调用的函数库保存位置                                 |
  | /usr/local/       | 手工安装的软件保存位置，**一般建议原码包软件安装在这个位置** |
  | /usr/share/       | 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录   |
  | /usr/src/         | 源码包保存位置，我们手工下载的源码包和内核源码包都可以保存到这里（**习惯把手工下载的源码包保存到/usr/local/src/目录中**，把内核源码保存到/usr/src/kernels/目录中) |
  | /usr/src/kernels/ | 内核源码的存放位置                                           |
  | /var/             | 动态数据保存位置，主要保存缓存、日志以及软件运行所产生的文件 |
  | /var/www/html/    | RPM包安装的Apache的网页主目录                                |
  | /var/lib/         | 程序运行中需要调用或改变的数据保存位置。如MySQL的数据库保存在/var/lib/mysql/目录中 |
  | /var/log/         | 系统日志保存位置                                             |
  | /var/run/         | 一些服务和程序运行后，它们的PID（进程ID）保存位置。是/run/目录的软链接 |
  | /var/spool/mail/  | 新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中   |
  | /var/spool/cron/  | 系统的定时任务队列保存位置。系统的计划任务会保存在这里       |

- #### linux的远程连接

  使用xshell（封装了ssh命令的作用）远程连接工具，macos使用ssh命令远程连接，ssh就是提供一个远程安全的加密远程连接

  远程连接的步骤

  ```
  1.确保你的linux机器正确配置的ip地址
  通过ip addr show查看linux的网络ip信息（ens33）192.168.10.3
  2.安装好xshell软件，进行远程连接
  3.直接使用ssh命令进行远程连接
  #解释：ssh 是linux远程登录的命令，  root用户，   ssh登录的用户@主机ip地址
  ssh   root@192.168.10.3 #这个命令就是远程连接命令，xshell其实也是敲打的整条命令而已
  4.如果用macos电脑进行Linux的远程连接方式与Windows相同
  ```

### 基础预认知

#### Linux命令行

命令的基本格式（[]是可以选项的意思，可写行，不写也行）

``` 
[root@localhost ~] # 命令 [选项] [参数]
```

选项：是用于调整命令的功能的

参数：是命令的操作对象，如果省略参数，是因为有默认参数

\代表这行没有写完，换行

|         命令         | 空格 | 参数（可写可不写）                 | 空格 | 文件，文件夹（可写可不写）             |
| :------------------: | ---- | ---------------------------------- | ---- | -------------------------------------- |
| ls列出文件夹中的内容 |      |                                    |      | /opt 根目录下的opt文件夹               |
|          ls          |      | -a all显示出所有文件以及隐藏的文件 |      | /opt                                   |
|          ls          |      | -a                                 |      | 如果不写则输出一个点，当前文件夹的内容 |
|          ls          |      |                                    |      |                                        |

基本命令用法如上

- 一般情况下，linux命令行的参数，都是可选的，可写可不写，不同的参数作用不一样

- Linux命令之间必须要用空格

- [root@localhost ~] # 

  | 符号      | 意思                                                      |
  | --------- | --------------------------------------------------------- |
  | []        | 这是提示符的分隔符号，没有特殊含义                        |
  | root      | 显示的是当前的登入用户                                    |
  | @         | 分隔符号，没有特殊含义                                    |
  | localhost | 当前系统的简写主机名（完整主机名是localhost.localdomain） |
  | ~         | 代表用户当前所在的目录，此例中用户当前所在的目录是加目录  |
  | #         | 命令提示符，超级用户是#，普通用户是$                      |

#### 命令相关：

##### 使用man tar 命令遇见的问题

"Manual page tar(1) line 1 (press h for help or q to quit)"是Linux系统终端中`man tar`命令的输出结果，它表示你正在查看`tar`命令的手册页面。

这个消息的含义是告诉你当前正在查看的是`tar`命令的手册页面，而数字1（在括号中）表示这是手册中的第一个部分。在这个特定的情况下，`(1)`表示这是用户命令的手册页。

按下"h"键可以获得更多帮助，而按下"q"键则退出手册页查看。你可以使用箭头键上下滚动查看手册的其他部分。如果需要特定节的帮助，也可以输入相应的节号，例如`man tar`后跟着数字，如`man 5 tar`，来查看关于`tar`配置文件的手册页。

##### 对README文档、Install文档和FAQ文档的认知

1. **README文档：**
   - **目的：** README文档是一个项目的入口点，提供了对软件项目的简要概述和基本信息，以帮助用户、开发者和贡献者快速了解项目。
   - **内容：** 通常包括项目的描述、安装说明的简要摘要、基本使用方法、项目结构概览、贡献指南、许可证信息等。README文档通常以纯文本或者Markdown格式编写。
2. **Install文档：**
   - **目的：** Install文档用于提供软件的安装和配置说明，以确保用户能够成功地将软件部署到他们的系统上。
   - **内容：** 包括安装前的准备工作、依赖项、安装步骤、配置选项、常见问题和解决方案等。这可以是一个独立的文档，也可以包含在README文档中的一个独立部分。
3. **FAQ文档：**
   - **目的：** FAQ（常见问题解答）文档旨在回答用户和开发者经常提出的问题，提供解决方案和帮助。
   - **内容：** 包括针对常见问题的解答、遇到问题时的故障排除步骤、已知问题列表、常见错误的修复等。FAQ文档通常不是软件的详尽技术文档，而是专注于解决常见问题。

这三个文档通常一同提供，以便用户轻松入门、安装并使用软件，同时能够在遇到问题时快速找到帮助。综合这些文档，用户能够更好地理解软件项目的功能、用途，以及如何正确地配置和使用。

#### Linux终端快捷键：

1. **基本导航快捷键：**
   - **Ctrl + A：** 将光标移动到行首。
   - **Ctrl + E：** 将光标移动到行尾。
   - **Ctrl + U：** 删除光标之前的文本。
   - **Ctrl + K：** 删除光标之后的文本。
2. **历史命令快捷键：**
   - **Ctrl + R：** 搜索并执行历史命令。
   - **Ctrl + L：** 清屏（类似于`clear`命令）。
   - **!!：** 重新执行上一条命令。
3. **光标移动快捷键：**
   - **Ctrl + F：** 向前移动光标。
   - **Ctrl + B：** 向后移动光标。
   - **Alt + F：** 向前跳一个单词。
   - **Alt + B：** 向后跳一个单词。
4. **其他常见快捷键：**
   - **Ctrl + C：** 中止当前命令。
   - **Ctrl + D：** 注销或结束当前Shell会话。
   - **Ctrl + Z：** 将当前命令置于后台。
   - **Tab：** 自动补全文件或命令。
   - **Shift + Page Up/Page Down：** 在终端中滚动。
5. **命令行编辑快捷键：**
   - **Alt + U：** 将当前单词转换为大写。
   - **Alt + L：** 将当前单词转换为小写。
   - **Alt + .（点号）：** 插入上一条命令的最后一个参数。

#### 复制、粘贴和剪切文本常用快捷键：

1. **复制和粘贴：**
   - **Ctrl + Shift + C（或 Ctrl + Insert）：** 复制选定的文本。
   - **Ctrl + Shift + V（或 Shift + Insert）：** 粘贴剪贴板中的文本。
2. **剪切：**
   - **Ctrl + Shift + X（或 Shift + Delete）：** 剪切选定的文本。
3. **在终端中的复制和粘贴：**
   - **Ctrl + Shift + C：** 在终端中复制文本。
   - **Ctrl + Shift + V：** 在终端中粘贴文本。
4. **复制整行：**
   - **Ctrl + Shift + Alt + ↑（或 Ctrl + Shift + ↑）：** 复制光标所在行。
5. **清除行：**
   - **Ctrl + U：** 删除光标之前的文本。
   - **Ctrl + K：** 删除光标之后的文本。

## 二、shell

### 1、对shell的认知

shell就是围绕在linux内核之外的一个“壳”程序，用户在操作系统上完成的所有任务都是通过shell与Linux系统内核的交互来实现的。shell本身是一个以C语言编写的程序，是用户和操作系统内核之间通信桥梁。作为**命令解释程序**，shell解释用户输入的命令，然后提交给内核处理，最后把结果返回给用户。

shell自身解释执行的命令称为**内置命令**，Shell内置命令是直接由Shell解释器执行的命令，而不是通过调用外部程序执行。

shell还是强大的**解释型程序设计语言**，它定义了各中选项和变量，几乎支持高级程序语言的所有程序结构，如变量、函数、表达式和循环等。利用shell可以编写shell脚本程序，类似于windows/DOS下的批处理文件。

### 2、Shell内置命令与Bash的关系：

1. **Bash是一种Shell：**
   - Bash是一种Shell程序，它是Bourne Shell的扩展和改进版本。Bash提供了许多功能，包括命令历史、自动补全、条件测试、循环结构等。Bash（**Bourne Again SHell**）是Linux系统中最常用的Shell之一，也是许多Linux发行版的默认Shell。
2. **Shell内置命令是Bash的一部分：**
   - Bash内置了一些常用的命令，这些命令是Shell解释器的一部分，而不是外部可执行程序。这使得这些命令的执行更加高效，因为它们不需要创建新的进程。

### 3、常见的Shell内置命令及其用途：

#### shell的命令格式

|    command     |   [options]    |  [arguments]   |
| :------------: | :------------: | :------------: |
| 表示命令的名称 | 表示命令的选项 | 表示命令的参数 |

**options：**

包含一个或多个字母的代码，主要用于改变命令的执行格式。一般在选项前面有一个“-”符号，用于区分参数。

**arguments**

参数是在选项后面紧跟的一个或多个字符串，这些字符串指定命令的操作对象，比如文件或者目录。

#### shell的通配符

主要为了方便用户对文件或者目录的描述，shell将把与命令行中指定的匹配规则符合的左右文件名，或者路径名作为命令的参数。

1. **星号 `\*`：通配任意字符序列**
   - **作用：** 匹配零个或多个字符。
   - **用法：** `*.txt` 匹配所有以 `.txt` 结尾的文件。
   - **例子：** `ls *.txt` 会列出当前目录下所有以 `.txt` 结尾的文件。
   
2. **问号 `?`：通配单个字符**
   - **作用：** 匹配任意单个字符。
   - **用法：** `file?.txt` 匹配 `file1.txt`、`fileA.txt` 等。
   - **例子：** `ls file?.txt` 列出所有符合模式的文件。
   
3. **方括号 `[...]`：字符类**
   - **作用：** 匹配方括号内的任意一个字符。
   - **用法：** `[aeiou]` 匹配任意一个元音字母。
   - **例子：** `ls file[123].txt` 列出 `file1.txt`、`file2.txt`、`file3.txt`。
   
4. **花括号 `{...}`：扩展列表**
   - **作用：** 生成由花括号内的逗号分隔的所有字符串组成的列表。
   - **用法：** `file{1,2,3}.txt` 等同于 `file1.txt file2.txt file3.txt`。
   - **例子：** `cp file{1,2,3}.txt backup/` 复制文件1、2、3到backup目录。
   
5. **取反 `!`：排除匹配项**
   - **作用：** 在字符类中，用于取反匹配。
   
   - **用法：** `[!0-9]` 匹配除了数字之外的任意字符。

   - **例子：** `ls [!aeiou]*` 列出不以元音字母开头的文件。
   
     | 命令                  | 用途                                                         |
     | --------------------- | ------------------------------------------------------------ |
     | **cd：**              | 用途：切换当前工作目录。                                     |
     | **echo：**            | 用途：打印文本到标准输出。                                   |
     | **pwd：**             | 用途：显示当前工作目录的路径。                               |
     | **export：**          | 用途：设置或显示环境变量。                                   |
     | **alias：**           | 用途：创建命令别名。                                         |
     | **unset：**           | 用途：取消设置变量或函数。                                   |
     | **type：**            | 用途：显示命令的类型，是内置命令、外部命令还是别名。         |
     | **source（或`.`）：** | 用途：在当前Shell环境中执行命令文件，而不是启动一个新的进程。 |
     | **history：**         | 用途：显示命令历史记录。                                     |
     | **exit：**            | 用途：退出当前Shell会话。                                    |
     | **eval：**            | 用途：将参数作为Shell命令执行。                              |

这些是一些常见的Shell内置命令，它们提供了基本的操作和控制Shell环境的功能。每个Shell可能有一些特定于该Shell的内置命令，但上述列举的是在大多数常见的Unix-like系统上通用的内置命令。

### 4、shell的重定向

在Shell中，重定向是一种机制，通过它可以改变命令的标准输入、标准输出和标准错误的默认行为，将它们与文件或其他命令进行连接。这种机制允许将命令的输出保存到文件中、从文件中读取输入，以及将命令的错误输出与标准输出分开等。

#### 1>. **标准输入、标准输出和标准错误：**

- **标准输入（stdin，文件描述符0）：** 默认为键盘输入，命令从标准输入中读取数据。
- **标准输出（stdout，文件描述符1）：** 默认为终端，命令将结果输出到标准输出。
- **标准错误（stderr，文件描述符2）：** 默认为终端，命令将错误消息输出到标准错误。

#### 2>. **重定向符号：**

- **`>`：** 用于将标准输出重定向到文件，会覆盖文件的内容。

  ```
  command > file.txt
  ```

- **`>>`：** 用于将标准输出追加到文件，不会覆盖文件的内容。

  ```
  command >> file.txt
  ```

- **`<`：** 用于将文件内容重定向到命令的标准输入。

  ```
  command < file.txt
  ```

- **`2>`：** 用于将标准错误重定向到文件。

  ```
  command 2> error.txt
  ```

- **`2>>`：** 用于将标准错误追加到文件。

  ```
  command 2>> error.txt
  ```

- **`&>` 或 `>file 2>&1`：** 用于将标准输出和标准错误都重定向到同一个文件。

  ```
  command &> output_error.txt
  ```

#### 3>. **原理：**

当你使用重定向时，Shell会改变相应文件描述符的默认目标。例如，`>` 将标准输出的文件描述符（1）的目标更改为**指定的文件**。通过这种方式，你可以将命令的**输出保存到文件**中，而不是显示在终端上。

在重定向时，文件描述符的数字可以省略，默认为标准输出。例如，`command > file.txt` 和 `command 1> file.txt` 是等价的。

使用 `2>` 或 `2>>` 可以将标准错误重定向到文件。`&>` 可以同时重定向标准输出和标准错误。

这些重定向机制使得在Shell中可以更灵活地处理命令的输入和输出，有助于**脚本编写**、**日志记录**以及调试过程。

### 5、shell的管道

Shell管道（Pipeline）是一种将一个命令的输出作为另一个命令的输入的机制，通过使用竖线 `|` 符号实现。这种机制允许将多个命令组合在一起，形成一个处理数据的链条。管道在Unix-like系统中的工作原理如下：

**Shell 管道的基本语法：**

```
command1 | command2
```

这表示将 `command1` 的输出作为 `command2` 的输入。

#### **工作原理：**

1. **创建进程：**
   - 每个命令都在单独的进程中执行。
2. **建立管道：**
   - Shell创建一个管道，将`command1`的标准输出连接到管道的写入端，将`command2`的标准输入连接到管道的读取端。
3. **数据传递：**
   - `command1` 执行并将输出写入管道。
   - `command2` 从管道读取 `command1` 的输出作为输入。
4. **进程协同：**
   - 数据在管道上传递，实现了命令之间的协同工作。

**示例：**

```
ls -l | grep "txt"
```

上述命令通过管道将 `ls -l` 的输出传递给 `grep "txt"`，以筛选出包含 "txt" 的文件。

**多重管道：**

可以通过多个管道连接多个命令，形成更复杂的数据处理链。

```
command1 | command2 | command3
```

#### 管道的应用：

1. **数据筛选：**
   - 通过 `grep`、`awk`、`sed` 等命令对数据进行筛选和转换。
2. **数据排序：**
   - 使用 `sort` 命令对数据进行排序。
3. **数据计算：**
   - 使用 `awk` 或 `perl` 进行数据计算和处理。
4. **数据统计：**
   - 使用 `uniq`、`wc` 等命令进行数据统计。
5. **进程通信：**
   - 用于在不同进程之间传递数据。

Shell管道是Unix-like系统中非常强大和灵活的工具，允许用户将简单的命令组合在一起，以实现复杂的数据处理和操作。

### 6、shell的引用

在Shell编程中，引号用于对字符串进行引用，控制字符串的解释和展开方式。主要有单引号（'）、双引号（"）和反引号（`）三种形式。

**1. 单引号（'）：**

单引号用于保留字符串的字面含义，不对其中的任何字符进行解释。在单引号中，所有字符都会按照原样输出，不进行变量替换、通配符扩展或命令替换。

```
echo 'This is a string with $variable and * wildcard.'
```

上述命令中，`$variable` 和 `*` 都会被直接输出而不进行替换。

**2. 双引号（"）：**

双引号用于对字符串进行弱引用，允许变量替换和转义字符的使用。在双引号中，变量会被替换为其值，而反斜杠（\）用于转义字符。

```
codevariable="world"
echo "Hello, $variable!"
```

上述命令中，`$variable` 会被替换为其值，输出为 "Hello, world!"。

**3. 反引号（`）：**

反引号用于进行命令替换，执行被引用命令并将其输出嵌入到整个命令中。注意，反引号在一些场景下可能被弃用，推荐使用 `$()` 代替。

```
codecurrent_date=`date`
echo "Current date: $current_date"
```

上述命令中，`date` 命令的输出被嵌入到 `echo` 命令中。

**总结：**

- **单引号：** 强引用，不进行任何替换。
- **双引号：** 弱引用，允许变量替换和转义字符。
- **反引号：** 执行命令并将其输出嵌入到整个命令中（推荐使用 `$()` 替代）。

引号在Shell脚本中非常重要，能够确保字符串的正确解释，防止特殊字符引起的问题，并控制变量和命令的替换方式。

## 三、常用命令

### 1、系统的管理与维护

**ls**：ls命令显示指定工作目录下的内容，列出工作目录所含的文件及子目录。

​       ls [选项] [路径或文件]

```
-l：说明： 以长格式（详细列表）显示文件信息。         例子： ls -l
-a：说明： 显示所有文件，包括以.开头的隐藏文件。      例子： ls -a
-h：说明： 以人类可读的格式显示文件大小。            例子： ls -lh
-t：说明： 按修改时间排序，最新的文件在最前面。       例子： ls -t
-r：说明： 反向排序，逆序显示文件。                 例子： ls -r
-R：说明： 递归显示子目录内容。                    例子： ls -R
-S：说明： 按文件大小排序，最大的文件在最前面。       例子： ls -S
-d：说明： 显示目录本身而非其内容。                 例子： ls -d
-i：说明： 显示文件的inode号码。                   例子： ls -i
-G：说明： 在长格式下，不显示group信息。            例子： ls -lG
```

**pwd**：显示当前的工作目录，执行pwd指令可立刻得知目前所在的工作目录     

​            的绝对路径名称。        

**cd**:      改变当前工作目录，其用法与Windows下的cd类似。

```
切换到指定目录：cd /path/to/directory
说明： 切换当前工作目录到指定的目录。
返回上级目录：cd ..
说明： 切换当前工作目录到上级目录。
返回家目录:cd ~或者cd
说明： 切换当前工作目录到用户的家目录。
返回前一目录:cd -
说明： 切换当前工作目录到上一次所在的目录。
```

**date**:    显示或修改系统时间与日期。（只有超级用户可以使用date来设置时             

​              间），一般用户只能用date显示时间。

​              date [选项] 显示时间格式(以+开头，后面接时间格式)

```
       -d, --date=STRING
              显示由 STRING 指定的时间, 而不是当前时间
       -s, --set=STRING
              根据 STRING 设置时间
```

**passwd**：用于更改用户密码。在使用 `passwd` 命令时，具体的行为取决于你           

​                  有没有超级用户权限（root 或具有 sudo 权限的用户）。

```
passwd                               普通用户要修改自己的密码
sudo passwd username                 超级用户更改(sudo)用户密码
                用具有 sudo 权限的用户替换 username，然后输入超级                 用户密码。系统会提示你输入新密码两次以确认。
sudo passwd root                     设置超级用户密码
passwd username                      超级用户修改普通用户密码
```

**su**：主要用于改变用户身份        su [选项] [用户名]

```
su             切换到超级用户(root)
su username    切换到指定user
su - username  切换到其他用户并保留环境变量，使用‘-’可以保留目标用户                的环境变量，是切换后的环境更接近于目标用户
su -l          使目前的shell成为改变身份后用户默认的shell
su -c          改变身份后运行一个指令后就结束
su -m          改变用户身份，但不改变环境变量
示例：$su -c passwd 在普通用户A下修改超级用户的密码
```

**clear**：用于清除屏幕信息

**man**：用于显示指定命令的帮助信息      man[命令名称]     示例：#man ls

**who**：用于显示目前登录到系统的用户信息，他会列出当前终端上的登录用

​            户，并显示相关的信息，如用户名、终端、登录时间等       who [选项] [file]

​            在Linux下who通常通过/var/run/utmp文件来获取信息，如果“[file]”选项指定另一个文件，则who命令            

​            不再默认读取/var/run/utmp文件，而是读取指定文件来获取信息。

```
who命令的一般输出格式如下。
名称 [状态] 终端 时间 [活动] [进程标识]（主机名）
·名称：用户的登录名。
·状态：表明终端是否对用户都是可写的。
·终端：类似于pts/1、pts/2等，此终端标识在/dev目录中可找到。
·时间：用户登录系统的时间。
·活动：某个用户在自己的终端上最后一次活动发生以来到现在的时间，如果此项是个“.”，就表示一分钟内的终端活动；如果终端保持静止已经超过24小时或自从系统启动以来还没有被使用过，那么此项标记为“old”。
·进程标识：用户登录shell的进程id。
·主机名：登录到Linux系统上的客户端机器标识。
```

```
who -H             以表格的形式显示用户信息，包括列标题。
who -q             只显示登录用户总数和各用户登录终端的数量
who -u             显示详细的登录用户信息，包括登录用户、终端、登录时间和空闲时间等。
who -a             列出所有信息，相当于所有选项。
who -b             列出系统最近启动的日期。
who -l             列出所有可登录的终端信息。
```

**w**:   用于显示登陆到系统的用户信息，类似于who，但提供更详细的信息，包括用户的登陆时长、运行命令等。

​         w [选项] [用户]        /[用户]表示当指定用户后，只显示该用户的信息

```
w -h  隐藏表头
w -u  显示详细登录用户、终端、IP地址、登录时间、运行的命令和登录时长
w -v  显示版本信息
```

![屏幕截图 2024-01-20 230424](D:\桑梓\24寒假作业\屏幕截图 2024-01-20 230424.png)

```
·上面第1行输出显示了当前的系统时间、系统从启动到现在已经运行的时间、登录到系统中的用户数和系统平均负载。平均负载是指在1分钟、5分钟、15分钟内系统负载状况。
·USER：表示登录系统的用户。
·TTY：表示用户使用的TTY名称。
·FROM：表示用户从哪里登录进来，一般显示远程登录主机的IP地址或者主机名。
·LOGIN@：用户登录的日期和时间。
·IDLE：表示某个程序上次从终端开始执行到现在所持续的时间。
·JCPU：表示该终端上的所有进程及子进程使用系统的总时间。
·PCPU：当前活动进程使用的系统时间。
·WHAT：当前用户执行的进程名称和选项。
```

**uname**：用于显示操作系统相关信息，例如系统名称、内核版本、操作系统类型等。

```
-a               显示所有信息，包括系统名称、节点名称、内核版本、操作系统、硬件架构等。
-s               显示内核名称。
-n               显示网络节点主机名。
-m 或 --machine： 显示硬件架构。
```

**uptime**：用于输出系统任务队列信息。

**last**：       列出目前与过去登入系统的用户相关信息。当执行last指令时，它会默认读取位于/var/log目录下名称

​                  为wtmp的文件，并把该给文件记录的登入系统的用户名单全部显示出来。

```
"-n"：指定要显示的行数，例如 "last -n 5" 会显示最近的5次登录记录。
"-a"：显示完整的登录和注销时间。
"-d"：显示指定日期之后的登录记录。
"-f"：显示特定文件的登录记录。
```

**dmesg**：显示开机信息。内核会将开机信息存储在系统缓冲区（ring buffer）中，如果开机来不及查看相关信

​                息，可以在开机后利用dmesg命令查看，也可以在/var/log/目录中查看dmesg文件。通常用于诊断系

​                统启动时的硬件问题和错误。   

```
"-H"：以人类可读的格式显示时间戳。
"-T"：显示时间戳，以便更容易理解消息的发生时间。
"-l"：根据消息级别过滤显示消息，例如 "-l err" 只显示错误消息。
```

**free**：用于显示系统内存状态，具体包括系统物理内存、虚拟内存、共享内存和系统缓存。

```
"-h"：以人类可读的格式显示内存大小（以 GB、MB 等单位）。
"-m"：以兆字节 (MB) 为单位显示内存大小。
"-g"：以 GB 为单位显示内存大小。
```

**ps**：  显示系统进程在瞬间的运行动态，它可以显示系统中所有进程的详细信息，包括进程 ID (PID)、占用的内

​          存和 CPU 资源、执行时间等。

```
"aux"：显示所有用户的所有进程，包括其他用户的进程。
"e"：显示所有进程，而不仅仅是与当前终端相关的进程。
"f"：以树状结构显示进程。
```

```
默认ps命令输出使用者自己的进程。其中，
·PID是进程的标识号；
·TTY是进程所属的终端控制台；
·TIME列是进程所使用的总的CPU时间；
·CMD列列出正在执行的命令行。
```

注意

 ps命令是Linux系统最基本、最常用的且非常强大的进程查看命令，使用该命令可以确定哪些进程在运行，进程

占用了多少资源，是否合理，运行状态是否正常，进程是否结束，进程有没有僵死现象，等等。该命令最常用

的选项就是e、f、a、u，相应的选项组合为**ps -ef**、**ps aux**，可以通过这些组合准确定位系统进程运行状态。

**top**： 提供了对系统处理器状态的实时监控，它能够实时显示系统中各个进程的资源占用状况。该命令可以按照

​           对CPU的使用、内存使用和执行时间对系统任务进程进行排序显示，同时top命令还可以通过交互式命令           

​           进行设定显示。类似**Windows的任务管理器**。

```
以下是 "top" 命令中常用的交互式命令：
"k"：结束指定进程。输入"k"后，会提示输入要结束的进程号，然后按回车确认。
"q"：退出 top 命令。
"h"：显示帮助信息，列出所有交互式命令的说明。
"1"：切换到单核心模式，只显示单核心的 CPU 信息。
"r"：修改进程的优先级，输入进程号和新的优先级值后按回车确认。
常用选项包括：
"-d"：指定刷新间隔时间，例如 "-d 5" 表示每5秒刷新一次。
"-u"：指定只显示指定用户的进程。
"-p"：指定只显示指定进程号的信息。
```

### 2、文件管理与编辑

**mkdir**： 用于创建一个目录。(make directory)        mkdir [选项] 目录名

```
mkdir -p /home/user1/user2                       在/home目录下创建了嵌套目录user1/user2
```

**more**：用于显示较长的文本内容，space显示下一屏，enter显示文本下一行     more [选项] 文件名

**cat**：    用于连接文件并显示文件内容，还可以创建新文件，在屏幕上显示文件内容。

```
-n：显示行号。
-A：显示所有控制字符。
-b：非空白行显示行号。
-s：压缩多个空白行。
cat > newfile.txt  创建新文件并写入内容，最后按CTRL+D结束
cat file1.txt file2.txt  连接多个文件并显示内容
cat file1.txt file2.txt >file3.txt 将文件1和文件2内容合并后输出到文件3中。
```

**diff**：用于比较文件的差异，可比较文本文件，或者目录，比较出目录中相同文件名的文件（不会比较子目录）

​           diff [选项] 文件1 文件2

```
-u 或 --unified：以统一的格式显示差异。
-i 或 --ignore-case：忽略大小写的差异。
-r 或 --recursive：递归比较目录中的文件。
```

**grep**：文本过滤工具，根据指定的字符串，对文件的每一行进行搜索，找到就整行输出。

​             grep [选项] pattern [files] (global  regular  expression)

```
-i：忽略大小写进行匹配。
-v：反向查找，只打印不匹配的行。
-n：显示匹配行的行号。
-r：递归查找子目录中的文件。
-l：只打印匹配的文件名。
-c：只打印匹配的行数。
```

**rm**:  用于删除某个目录及其下的所有文件及子目录。（对于链接文件，只是断开了链接，源文件保持不变）

​         rm [选项] 文件或者目录

```
-i 删除前逐一询问确认。
-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
-r 将目录及以下之档案亦逐一删除。
rm -r *  删除当前目录下的所有文件及目录
rm -rf test/   删除目录test，不管该目录下是否有子目录或文件，都直接删除
```

**touch**：用来改变指定文件的访问时间和修改时间，若指定文件不存在则创建此文件。

​               touch [-acfm] [-d<日期时间>] [-r<参考文件或目录>] [-t<日期时间>] [--help] [-v] [文件或目录]

```
a 改变档案的读取时间记录。
m 改变档案的修改时间记录。
c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
f 不使用，是为了与其他 unix 系统的相容性而保留。
r 使用参考档的时间记录，与 --file 的效果一样。
d 设定时间与日期，可以使用各种不同的格式。
t 设定档案的时间记录，格式与 date 指令相同。
--no-create 不会建立新档案。
--help 列出指令格式。
--version 列出版本讯息。
```

**ln**：用于在文件或目录之间创建链接，为某一个文件在了另一个位置建立一个同步链接（link）

​        ln [参数] [源文件或目录] [目录文件或目录]

#### 硬链接&软链接

| 档案 |                            软链接                            |                            硬链接                            |
| ---- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 定义 | symbolic link 产生一个特殊的档案，该档案的内容指向另一个档案的位置。 | 存在同一个文件系统中，通过文件的inode编号来进行来链接，多文件指向同一个inode号（Inode Index）（在Linux系统中允许）。 |
| 类似 | 类似Windows中的快捷方式，软链接是一个指向真正的文件或者目录位置的符号链接 | 允许一个文件拥有多个有效的路径名，以文件的副本的形式存在，但不占用实际空间 |
| 允许 |     可以对一个不存在的文件名进行链接，可以对目录进行链接     |                    不允许对目录创建硬链接                    |
|      |                        可以跨文件系统                        |      不允许跨系统（在Linux中允许多文件用同一个inode号）      |

```
必要参数：
--backup[=CONTROL] 备份已存在的目标文件
-b 类似 --backup ，但不接受参数
-d 允许超级用户制作目录的硬链接
-f 强制执行
-i 交互模式，文件存在则提示用户是否覆盖
-n 把符号链接视为一般目录
-s 软链接(符号链接)
-v 显示详细的处理过程
选择参数：
-S "-S<字尾备份字符串> "或 "--suffix=<字尾备份字符串>"
-V "-V<备份方式>"或"--version-control=<备份方式>"
--help 显示帮助信息
--version 显示版本信息
```

![](D:\桑梓\24寒假作业\屏幕截图 2024-01-21 174605.png)

**file**：用于辨识显示文件类型。file [-bcLvz] [-f<名称文件>] [-m<魔法数字文件>...] [文件或目录...]

![](D:\桑梓\24寒假作业\屏幕截图 2024-01-21 175534.png)

``` 
-b 　列出辨识结果时，不显示文件名称。
-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。
-f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。
-L 　直接显示符号连接所指向的文件的类别。
-m<魔法数字文件> 　指定魔法数字文件。
-v 　显示版本信息。
-z 　尝试去解读压缩文件的内容。
[文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。
```

**cp**:      用来将给出的文件或者目录复制到另一个文件或者目录中。（类似Windows中的copy）

​            cp [options] source dest    &    cp [options] source...  directory

```
-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。
-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。
-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。
-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。。
-u 或 --update：仅复制源文件中更新时间较新的文件。
-v 或 --verbose：显示详细的复制过程。
-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。
-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。
-l：不复制文件，只是生成链接文件。
cp -r /home/oracle /home/ixdba 将/home/oracle目录及其子目录下的全部内容复制到/home/ixdba下。
```

**find**：用来在指定的路径下查找指定的文件。`.`表示当前目录，`/`表示系统根目录

​          语法`find [路径] [匹配条件] [动作] `

```
-options
-name “字符串” 查找文件名匹配所给字符串的所有文件，字符串内可用通配符*、？、[]、
-lname“字符串 查找文件名匹配所给字符串的所有符号链接文件，
-gid n     查找ID号为n的用户组的所有组件
-uid n     查找属于ID号为n的用户的所有文件
-empty     查找大小为0的目录或文件
-path“字符串”    查找路径名匹配所给字符串的所有文件
-group“字符串”   查找属于用户组名为所给字符串的所有的文件
-depth          逐层查找当前目录到子目录
-prune          指出搜索时不搜索该目录。（如果同时用-depth，-prune将被忽略）
-size n         查找文件长度为n块的文件
-user“字符串”    查找特定用户的文件
-print          选项用于将搜索结果输出到标准输出（通常是终端）。
-type 文件类型    按指定文件类型搜索。b（块设备文件）、c（字符设备文件）、f（普通文件）、l（符号链接）、d（目录）、p（管道）、s（socket）
sudo find / -path "/usr/bin" -prune -o -name "main.c" -user root -type f
该命令从根目录 (/) 开始搜索。
它避免进入 /usr/bin 目录。
它寻找文件名为 "main.c"，属于 root 用户，且为普通文件的文件。
sudo 用于确保 find 命令具有足够的权限，以搜索受限制的目录并访问 root 用户拥有的文件。
sudo find / \( -path /var/log -o -path /usr/bin \) -prune -o -name "main.c" -print
该命令从根目录 (/) 开始搜索。
如果路径为 /var/log 或 /usr/bin，则阻止 find 进入这些目录。
它寻找文件名为 "main.c" 且不在 /var/log 或 /usr/bin 目录下的文件，然后打印这些文件的路径。
\( -path /var/log -o -path /usr/bin \)：这是一个复杂的条件表达式，使用括号将两个条件组合在一起。它的意思是“路径为 /var/log 或路径为 /usr/bin”。
```

**split**:  用来分割文档，将一个文件分成数个。

​           split  [--help] [--version]  [- <行数>] [-b <字节>] [-C <字节>] [-l <行数>] [要切割的文件] [输出文件名]

**mv**：  用来将文件或者目录改名或将文件由一个目录移入另一个目录中。如果源类型和目标类型都是文件或者                   

​            目录，`mv`将进行目录重命名。

```
languages grammer 
mv [options] source dest
mv [options] source... directory
parameter specification
-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。
-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
-n: 不要覆盖任何已存在的文件或目录。
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
```

### 3、压缩与解压缩

**zip&unzip**：将一般文件或者目录进行压缩或者解压，默认生成以“.zip"为后缀压缩包。（类似WinZip）

```
 zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]
-r：递归地压缩目录及其内容。
-u：更新已存在的压缩文件。
-q：静默模式，不显示压缩过程的输出。
-d：从压缩文件中删除指定文件。
-e：加密压缩文件。
-r：递归地压缩目录及其内容。
-n<字尾字符串>: 不压缩具有特定字尾字符串的文件。
-b<工作目录>: 指定暂时存放文件的目录。
-t<日期时间>: 把压缩文件的日期设成指定的日期。
-<压缩效率>： 压缩效率是一个介于1-9的数值。
-i<范本样式>： 只压缩符合条件的文件。
-x<范本样式>: 压缩时排除符合条件的文件。
 unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]
-d：指定解压缩的目录。
-l：列出压缩文件的内容，但不解压。
-q：安静模式，不显示解压缩过程的输出。
-o：不提示用户，直接覆盖已存在的文件。
-P：指定解压缩时的密码。
```

**gzip&gunzip**:将一般的文件进行压缩或者解压缩，压缩文件预设的扩展名为 `.gz`(gunzip是gzip的硬链接) 

​                        只能对文件进行压缩，即使指定压缩的目录，也只能压缩目录内的所有文件。

```
gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]
-d：解压缩模式。
-c：将压缩或解压的内容输出到标准输出。
-k：保留原始文件，不删除压缩前的文件。
-f：强制操作，不询问用户。
-r：递归处理目录及其内容。
```

**bzip2&bunzip2**：对文件进行压缩与解压缩。此命令类似于“gzip/gunzip”命令，只能对文件进行压缩。对于目 

录只能压缩目录下的所有文件，压缩完成后，在目录下生成以`.bz2` 为后缀的压缩包。bunzip2其实是bzip2的

符号链接，即**软链接**，因此压缩、解压都可以通过bzip2实现。         

**tar**：tar是Linux下经常使用的归档工具，对文件或者目录进行打包归档，归档成一个文件，但并不进行压缩。

```
tape archive（磁盘存档）
tar options archive-file files/directories
-c：创建新的归档文件。
-x：从归档文件中提取文件。
-f：指定归档文件的名称。（最后一个选项，后置名称）
-v：显示详细的操作过程，即 verbose 模式。
-z：使用 gzip 进行压缩或解压缩。
-j：使用 bzip2 进行压缩或解压缩。
-t：列出归档文件的内容。
-r：向归档文件中添加文件。
-u：只添加较新的文件。
-A：追加一个归档文件到另一个归档文件。
```

**dd**：用来转换或复制文件，同时对设备进行备份。

```
data dump （数据转储）
dd if=input_file of=output_file bs=block_size count=num_blocks
.if：就是输入文件，可以是设备，例如，磁盘某分区或者整个磁盘。
·of：就是输出文件，也可以是输出设备，例如，磁盘、磁带等。
·bs：指定一个block的大小，如果没有指定，默认为512字节。
·count：就是“bs”的数量
dd if=/etc/inittab of=/opt/inittab.bak       将/etc/inittab文件备份到/opt/inittab.bak中。
dd if=/dev/sda2 of=/opt/sda2.back        将/dev/sda2整个分区进行备份，保存备份文件到/opt目录。
                          这里的备份输出路径一定不能是“/dev/sda2”所在分区，否则怎么都备份不完的。
dd if=/opt/sda2.back of=/dev/sda2       将备份包/opt/sda2.back恢复到相应的分区，在恢复目标分区                    时，一定要先卸载目标分区，待恢复完成，再进行挂载。备份的分区最好和恢复的分区一致。
```

**cpio**：通过重定向的方式将文件进行打包、备份、还原、恢复的工具，可以解压以 `.cpio`或者`.tar`结尾的文

```
find /path/to/source -depth | cpio -o > archive.cpio                这将使用 find 命令列出 /path/to/source 目录下的所有文件和目录，并将其输出到 cpio 命令，生成一个名为 archive.cpio 的归档文件。
cpio -i < archive.cpio                    这将从 archive.cpio 中提取文件，并根据需要创建目录。
-o：创建归档文件。
-i：提取归档文件。
-d：在提取时自动创建目标目录。
-t：显示归档文件的内容列表。
-v：详细模式，显示操作过程。
-F：指定归档文件的名称。
cpio 的使用方式相对灵活，可以通过管道结合其他命令实现不同的备份和还原操作。
```

### 4、磁盘管理与维护

**df**：用来检查Linux系统的磁盘占用情况。df [选项]... [FILE]...

#### 对挂载点的理解

在Linux系统中，挂载点（Mount Point）是文件系统与目录之间的关联，通过挂载，一个文件系统的内容被连接（附加）到文件系统的目录中，使得文件系统中的内容可以在指定的目录中访问。通过挂载点，系统可以同时支持多个文件系统，并且可以将这些文件系统整合成一个统一的目录结构。

1. **devtmpfs**: `devtmpfs` 是一个内核提供的虚拟文件系统，用于挂载 `/dev` 目录，提供对设备文件的访问。
2. **tmpfs**: `tmpfs` 是一个临时文件系统，通常用于挂载 `/dev/shm` 和 `/run` 目录，提供共享内存和运行时文件存储。
3. **/dev/mapper/centos-root**: 这是一个逻辑卷管理器（LVM）创建的逻辑卷，挂载到根目录 `/`，包含操作系统的文件和目录。
4. **/dev/sda1**: 这是一个磁盘分区，挂载到 `/boot` 目录，存放启动相关的文件。
5. **tmpfs**（两个条目）: 临时文件系统用于用户运行时目录，分别挂载到 `/run/user/42` 和 `/run/user/0` 目录。

在总体上，挂载点是文件系统的入口，决定了文件系统中内容在整个目录树中的位置。例如，`/` 表示根目录，`/boot` 表示启动目录，`/dev` 表示设备目录等。通过挂载点，文件系统可以方便地集成到整个文件系统层次结构中。

```
-h：以人类可读的格式显示磁盘空间，以 K、M、G 等单位。
-T：显示文件系统类型。
-i：显示inode的使用情况。
-t：仅显示指定类型的文件系统。
--total：显示总计磁盘空间。
-x：排除指定类型的文件系统。
```

**du**：用来显示指定文件或目录所占用的磁盘空间情况。`du [options] [file/directory]`

```
-h：以人类可读的格式显示磁盘空间。
-s：仅显示总计磁盘空间。
-c：显示各个文件/目录的磁盘空间，并显示总计磁盘空间。
-k：以千字节为单位显示磁盘空间。
du 命令会递归地显示目录及其子目录的磁盘空间使用情况，并以默认情况下以 1K 块的大小为单位报告。
```

|        | du(Disk Usage)                                               | df(Disk Free)                                                |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用   | 用来显示指定目录或文件的磁盘空间使用情况。                   | 用来显示文件系统的整体磁盘空间使用情况                       |
| 关注点 | du关注的是文件和目录的实际磁盘空间使用情况，即占用的实际字节数。 | df关注的是整个文件系统的磁盘空间使用情况，包括总容量、已用空间、可用空间等信息。 |
| 总结   | `du` 用于查看指定目录或文件的实际磁盘空间使用情况。如果你想知道某个文件或目录占用了多少磁盘空间，使用 `du`。 | `df` 用于查看整个文件系统的磁盘空间使用情况。如果你想了解整个文件系统的空间使用情况，使用 `df`。 |

**fsck**：用来检查文件系统并尝试修复错误

`fsck [-sACVRP] [-t fstype] [--] [fsck-options] filesys [...]`

```
-a：自动修复文件系统，无需用户确认。
-y：在自动修复时回答 "yes"，无需用户确认。
-c：检查坏道。
-f：强制检查，即使文件系统标记为已清理。
-t filesystem_type：指定文件系统类型。
-n：仅显示将要执行的操作，而不实际执行。
-s: 依序一个一个地执行 fsck 的指令来检查
-r : 如果检查有错则由使用者回答是否修复
fstype 文件系统类型   filesys 设备名
在执行fsck命令修复某个文件系统时，这个文件系统对应的磁盘分区一定要处于卸载状态，磁盘分区在挂载状态下进行修复是极为不安全的，数据可能遭到破坏，也有可能损坏磁盘。
```

当fsck命令执行时，fsck如果发现存在没有文件系统依赖的文件或者目录，如果用户同意找回，fsck命令就会把这些孤立的文件或者目录放到lost+found目录下，并用这些文件自己对应的i-node号来命名，以便用户查找自己丢失的文件。lost+found的字面意思就是丢失并找回的含义。因此当用户在利用fsck命令修复磁盘分区以后，如果发现分区中有文件丢失，就可以到对应的lost+found目录中去查找。由于此时通过文件名称已经无法分辨文件，因此可以利用file命令查看文件系统类型，进而判断哪个是需要的文件。

**util-linux**：`util-linux` 是一个包含多个 Linux 工具的软件包，其中包括 `fsck`、`lsblk`、`mount` 等实用工具。

**sync**：强制把内存中的数据写回硬盘，以免数据丢失。

**eject**：用来退出抽取式设备，如光驱或磁带。如果该设备已经挂载，则eject先将设备卸载，然后再退出设备。

`eject [-dfhnqrstv] [-a<开关>] [-c<光驱编号>] [设备]`

```
[设备] 设备可以是驱动程序名称，也可以是挂入点。
-a<开关>或--auto<开关> 控制设备的自动退出功能。
-c<光驱编号>或--changerslut<光驱编号> 选择光驱柜中的光驱。
-d或--default 显示预设的设备，而不是实际执行动作。
-f或--floppy 退出抽取式磁盘。
-n或--noop 显示指定的设备。
-q或--tape 退出磁带。
-r或--cdrom 退出光盘。
-s或--scsi 以SCSI指令来退出设备。
-t或--trayclose 关闭光盘的托盘。
-v或--verbose 执行时，显示详细的说明。
```

**mount&umount**：挂载以及卸载指定的文件系统。

```
mount [选项] [-L<标签>] [-o<选项>] [-t<文件系统类型>] [设备名] [挂载点]
1）-L<标签>：标签其实就是磁盘分区标识的别名，标签可以随便起名，这样便于记忆，在Linux下磁盘分区的设备名比较难记，利用标签代替设备名，简单易记。
2）-o<选项>：指定加载文件系统时的选项，这些选项如下。
·async：以非同步的方式执行文件系统的输入、输出动作。
·atime：每次存取都更新inode的存取时间，默认设置，取消选项为noatime。
·auto：必须在/etc/fstab文件中指定此选项。指定-a选项时，会加载设置为auto的设备，取消选项为noauto。
·dev：可读文件系统上的字符或块设备，取消选项为nodev。
·exec：可执行二进制文件，取消选项为noexec。
·noatime：每次存取时不更新inode的存取时间。
·noauto：加入此选项，就无法使用-a选项来加载。
·nodev：不读文件系统上的字符或块设备。
·noexec：无法执行二进制文件。
·nosuid：关闭set-user-identifier（设置用户ID）与set-group-identifer（设置组ID）设置位。
·nouser：使用户无法执行加载操作，默认设置。
·iocharset=XXX：指定mount分区时使用的字符集。
·codepage=XXX：指定mount分区时使用的内码表。
·remount：重新加载设备。通常用于改变设备的设置状态。
·ro：以只读模式加载。
·rw：以可读写模式加载。
·suid：启动set-user-identifier（设置用户ID）与set-group-identifer（设置组ID）设置位，取消选项为nosuid。
·sync：以同步方式执行文件系统的输入、输出动作。
·user：可以让一般用户加载设备。
·defaults：使用默认选项。默认选项为rw、suid、dev、exec、anto、nouser与async。
3）-t<文件系统类型>：指定设备的文件系统类型，常用选项如下。
·ext3/ext2：Linux目前的常用文件系统。
·msdos：MS-DOS的FAT。
·vfat：Windows 95/98的VFAT。
·nfs：网络文件系统。
·iso9660：CD-ROM光盘的标准文件系统。
·ntfs：Windows NT的文件系统。
4）设备名：硬盘分区在Linux上的设备标识，类似于/dev/sda1、/dev/hda2等。
5）挂载点：Linux系统下指定的某个目录。
```

```
Windows+Linux双系统并存环境，将Windows下的D盘挂载到Linux下的/mnt/d目录下，并且支持中文，使用以下命令。
[root@localhost/]#mount -t vfat -ocodepage=936,iocharset=cp936 /dev/hda3 /mnt/d
上面的命令中，“-t vfat”选项表示需要挂载的D盘是FAT格式的文件系统；“-o”后面的选项指定了分区挂载后支持中文显示；“/dev/hda3”是Windows下的D盘在Linux下的硬件标识；“/mnt/d”是Linux系统上指定的挂载点，挂载成功就可以通过访问Linux下的/mnt/d目录来访问Windows下的D盘内容了。
```

#### 镜像、光驱、虚拟光驱，光盘镜像文件、ISO镜像文件

1. **镜像（Image）：**
   - **概念：** 在计算机领域中，镜像是指一个数据的复制，通常是对某个存储介质（如硬盘、光盘、USB驱动器）的一对一拷贝。这可以是整个磁盘的镜像，也可以是一个光盘或分区的镜像。
   - **应用：** 镜像文件通常用于备份、复制、恢复或分发数据。
2. **光驱（Optical Drive）：**
   - **概念：** 光驱是一种读取光盘的硬件设备，可以是 CD、DVD 或 Blu-ray 光盘驱动器。光驱通常用于读取和写入光盘上的数据。
   - **应用：** 光驱可用于安装操作系统、读取或写入数据，播放音频和视频等任务。
3. **虚拟光驱（Virtual Optical Drive）：**
   - **概念：** 虚拟光驱是一个在计算机上模拟的光盘驱动器，不依赖于实际硬件。它通过软件创建一个虚拟的光盘驱动器，可以加载光盘镜像文件，使操作系统和应用程序认为有一个真实的光盘驱动器。
   - **应用：** 虚拟光驱常用于避免使用物理光盘，而是加载光盘镜像文件作为虚拟光盘。
4. **光盘镜像文件（Optical Disc Image）：**
   - **概念：** 光盘镜像文件是光盘的一对一复制，以文件形式存储在计算机上。它包含了光盘上的所有数据，包括文件系统、文件和目录结构等。
   - **应用：** 光盘镜像文件可以用于备份、复制、存储和分发，也可以通过虚拟光驱加载并模拟光盘驱动器。
5. **ISO镜像文件（ISO Image）：**
   - **概念：** ISO镜像文件是一种标准化的光盘镜像文件格式，通常以 .iso 扩展名结尾。这种格式是光盘制造商用来制作实际光盘的标准格式，也常用于创建光盘镜像文件。
   - **应用：** ISO镜像文件是一种常见的光盘镜像格式，广泛用于操作系统安装、软件分发和数据存储等方面。

### 5、网络设置与维护

**ifconfig**: 用来配置网络或显示当前网络接口状态。类似于Windows下的ipconfig命令，必须root用户执行。

`ifconfig [选项] [interface] [inet|up|down|netmask|addr|broadcast]`

```
-a：显示所有网络接口信息，包括活动的和非活动的。
-s：仅显示每个接口的摘要数据，是有关接口活动性的，每个接口显示一行信息。
-v：如果某个网络接口出现错误。将返回错误消息，以帮助发现和处理故障。
·interface：网络接口名，在CentOS 7.x版本中，网络接口名变为类似enp0s1、enp0s2这样的标识，分别表示第1块网卡、第2块网卡和回环接口。
·up：激活一个网络接口。
·down：与up相反，使指定的网络接口无效。
·netmask：为一个指定的网络接口指定子网掩码。
·addr：这里的“addr”为网络接口指定的IP地址。
·broadcast：为指定的接口设置广播地址。
用ifconfig命令配置的网卡信息，在网卡重启或者机器重启后，所有的配置都失效了，
```

**scp**：（secure copy），用于将文件或者目录从一个Linux系统复制到另一个Linux系统下（使用SSH协议）。

```
scp 远程用户名@ip地址：文件的绝对路径本地Linux系统路径
scp 本地Linux系统文件路径远程用户名@ip地址：远程系统文件绝对路径名
[root@centos7 ～]#scp /home/ixdba/etc.tar.gz root@192.168.60.168：/tmp
目前我们处在IP为“192.168.60.133”的Linux系统下，计划将此系统下的/home/ixdba/etc.tar.gz文件复制到IP为“192.168.60.168”的远程Linux系统中root用户下的/tmp目录下
```

**netstat**：命令用于显示本机的网络连接、运行端口、和路由表等信息。

`netstat [-acCeFghilMnNoprstuvVwx] [-A<网络类型>] [--ip]`

```
-a：显示本机所有连接和监听端口
-n：以网络IP地址的形式显示当前建立的有效连接和端口
-r：显示路由表信息
-s：显示按协议的统计信息。默认情况下，将显示IP、IPv6、ICMP、ICMPv6、UDP和UDPv6的统计信息
-v：显示当前的有效连接，与“-n”选项类似。
-t：显示所有的TCP协议连接情况。
-u：显示所有的UDP协议连接情况。
-c<秒数>：表示每隔几秒就刷新显示一次。
-i：显示自动配置接口的状态。
-l：仅显示连接状态为“LISTEN"的服务的网络状态
-p：显示连接对应的PID与程序名。
A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。
```

**traceroute**：用来显示网络数据包传输到指定主机的路径信息，追踪数据路由状况。

`traceroute [选项] [远程主机或者IP地址] [数据包大小]`

```
-i<网络接口>：使用指定的网络接口发送数据包。
-n：直接使用IP地址，而不使用主机名。
-v：详细显示命令的执行过程。
-w<超时秒数>：设置等待远程主机回应的时间。
-x：开启或者关闭对数据包的正确性检验。
-s<来源ip>：设置本地主机发送数据包的IP地址。
-g<网关地址>：设置来源的路由网关，最多可设置8个。
traceroute -i ens33 -s 192.168.10.3 -w 10 www.baidu.com 100
跟踪从本机到网站www.baidu.com的数据包发送过程，
```

```
[root@localhost ~]# traceroute -i ens33 -s 192.168.10.3 -w 10 www.baidu.com 100
traceroute to www.baidu.com (39.156.66.18), 30 hops max, 100 byte packets
 1  gateway (192.168.10.1)  12.301 ms  12.083 ms  11.948 ms
 2  192.168.1.1 (192.168.1.1)  11.892 ms  11.848 ms  11.806 ms
 3  10.253.64.1 (10.253.64.1)  24.605 ms  24.581 ms  24.540 ms
 4  * * *
 5  221.183.77.209 (221.183.77.209)  24.658 ms 221.183.48.237 (221.183.48.237)  24.603 ms 221.183.77.209 (221.183.77.209)  24.573 ms
 6  221.183.37.181 (221.183.37.181)  44.581 ms 221.183.40.9 (221.183.40.9)  29.454 ms  29.329 ms
 7  * 221.183.49.126 (221.183.49.126)  39.493 ms 221.183.49.122 (221.183.49.122)  29.621 ms
 8  39.156.27.5 (39.156.27.5)  29.170 ms 111.13.0.174 (111.13.0.174)  26.816 ms 39.156.27.5 (39.156.27.5)  26.728 ms
 9  * 39.156.27.5 (39.156.27.5)  26.613 ms *
10  39.156.67.17 (39.156.67.17)  35.761 ms *  35.672 ms
11  * * *
12  * * *
13  * * *
星号和超时： 这可能是由于网络设备配置，拦截 ICMP 报文导致的。在某些情况下，路由器可能配置为不响应 ICMP 报文，这是为了提高安全性。
部分节点的缺失： 这可能是网络节点本身的问题，或者是网络节点配置导致的。如果这只是暂时的，可能是网络临时问题。
延迟时间： 如果延迟时间较高，可以联系你的互联网服务提供商（ISP）进行支持，以了解是否有网络拥塞或其他连接问题。
```

**telnet**：通过telnet协议与远程主机通信或者获取远程主机对应端口的信息。（与Windows下的telnet相似）

`telnet 主机名或者IP地址端口`

**wget**：用来从网络上下载某个软件，这个命令对于能够连接到互联网的Linux系统非常强大，可以直接从网络上下载自己需要的软件。

`wget [要下载软件的网址]`

### 6、文本编辑工具vim

Vim（Vi Improved）是一款强大的文本编辑器，是Unix和类Unix系统上的一种标准编辑器，也可在其他操作系统上运行。Vim是Vi编辑器的改进版本，提供了许多新特性和改进，同时保留了Vi的设计理念。Vim支持在终端中使用，也有图形用户界面（GUI）版本。

#### Vim的基本用法：

1. **启动Vim：**

   ```
   bashCopy code
   vim 文件名
   ```

2. **基本移动：**

   - 进入普通模式后，使用 `h`, `j`, `k`, `l` 进行光标移动。

3. **插入文本：**

   - 在普通模式下，按下 `i` 进入插入模式，可以开始输入文本。
   - 按下 `Esc` 返回普通模式。

4. **保存和退出：**

   - 在普通模式下，使用 `:w` 保存，`:q` 退出。
   - 使用 `:wq` 同时保存并退出，`:q!` 强制退出不保存。

5. **复制、粘贴和删除：**

   - 在普通模式下，使用 `dd` 删除一行，`yy` 复制一行，`p` 粘贴。

6. **搜索和替换：**

   - 在普通模式下，使用 `/` 进行向前搜索，`?` 进行向后搜索。
   - 使用 `:s/old/new/g` 进行替换。

7. **多级撤销和重做：**

   - 在普通模式下，使用 `u` 进行撤销，`Ctrl + r` 进行重做。

8. **退出Vim：**

   - 在普通模式下，使用 `:q` 退出，`:q!` 强制退出不保存。

## 四、Linux下软件的安装与管理

### 1、源码安装

**优点**：用户可以自己定制软件功能，安装需要的模块。可以自己选择安装路径，方便管理，卸载软件

#### **步骤**：

下载解压源码、分析安装平台环境（configure）、编译安装软件（make、make install）。

1. **解压源码包：**使用类似于 `tar` 命令解压源码包
2. **查看 README 文件：**README 文件通常包含有关软件的介绍、安装说明、配置选项等信息。可以使用文本编辑器查看。`cat README`
3. **运行 configure 脚本：**在解压后的源码目录中，通常会包含一个名为 `configure` 的可执行脚本。运行该脚本进行环境测试和配置。`./configure`，这个过程会检查系统环境，包括所需的库文件、工具和依赖项，并生成用于构建软件的 Makefile 文件。
4. **检查 configure 输出：**configure 脚本运行后，会输出一些信息和警告。检查这些输出，查看是否有关于缺少依赖项或特定库的提示。
5. **安装缺失的依赖项：**如果 configure 输出指示系统缺少某些依赖项，需要安装这些依赖项。可以使用包管理器安装。例如`sudo apt-get install libexample-dev`
6. **重新运行 configure：**安装依赖项后，可以再次运行 configure，确保系统现在满足软件的所有需求：`./configure`
7. **编译和安装：**完成 configure 后，使用 `make` 命令编译软件：然后，使用 `make install` 安装软件：
8. **完成安装：**安装成功后，软件就被成功地编译并安装到系统中。可以根据 README 文件提供的信息进行配置和使用。

#### Makefile

`Makefile` 是一种文本文件，通常用于定义和组织源代码的编译、链接和其他构建过程。`make` 工具根据 `Makefile` 文件中的规则和指令，自动化执行软件项目的编译过程，确保只有发生变化的部分被重新编译，从而提高构建效率。`Makefile` 文件是一种强大的构建工具，通过定义清晰的规则和依赖关系，可以轻松管理和维护复杂的项目。

### 2、RPM包方式安装

RPM（Red Hat Package Manager）是一种在基于RPM的Linux发行版上用于软件包管理的系统。在这种系统上，通过RPM包方式安装软件非常常见。以下是详细介绍RPM包方式安装的步骤：

#### 步骤

1.  **下载RPM包**：首先，需要从官方源或其他可信任的地方下载RPM包。通常，RPM包的文件名以 `.rpm` 结尾。`wget http://example.com/path/to/package.rpm`
2. **安装RPM包**：使用 `rpm` 命令来安装RPM包。可以使用以下命令：`sudo rpm -i package.rpm`
3. **升级RPM包**：如果已经安装了较旧版本的软件，并且想要升级到新版本，可以使用以下命令：`sudo rpm -U package.rpm`
4. **查询RPM包信息**：可以使用 `rpm` 命令查询已安装的软件包信息。要获取有关特定软件包的详细信息，包括版本和安装路径等：`rpm -qi package_name`
5. **卸载RPM包**：使用以下命令卸载已安装的软件包。`sudo rpm -e package_name`

#### 注意事项：

- 在安装或升级RPM包时，可能会遇到依赖关系问题。如果系统缺少某些依赖项，`rpm` 将报告错误并停止安装。在这种情况下，需要手动解决依赖关系，或者使用包管理器安装依赖项。
- 在升级软件包之前，建议备份相关数据，并确保了解新版本的变化和可能的不兼容性。

### 3、yum安装方式

`yum` 是一个在 Red Hat 及其衍生发行版（如 CentOS）上用于包管理的工具。它能够自动解决软件包之间的依赖关系，使得安装、升级和删除软件包变得更加简便。

#### 步骤

1. **安装软件包：**`sudo yum install package_name`
2. **升级软件包：**`sudo yum update package_name`
3. **卸载软件包：**`sudo yum remove package_name`
4. **搜索软件包：**`yum search keyword`
5. **列出所有已安装软件包：**`yum list installed`
6. **显示特定软件包信息：**`yum info package_name`
7. **清理缓存：**`sudo yum clean all`
8. **列出可用的软件包组：**`yum grouplist`
9. **安装软件包组：**`sudo yum groupinstall group_name`

**系统介绍**

在使用 `yum` 之前，首先需要了解系统的发行版本。`yum` 主要用于基于 Red Hat 的发行版，如 CentOS、Fedora 和 Red Hat Enterprise Linux（RHEL）等。这些系统通常使用 RPM（Red Hat Package Manager）软件包管理系统。

## 五、特殊权限

特殊权限是在文件和目录上设置的一些额外权限，它们超出了常规的读取、写入和执行权限。以下是一些常见的特殊权限，包括 ACL 权限、sudo 权限、SUID、SGID 和 SBIT 权限。

### 1、**ACL 权限（Access Control Lists）**

ACL 是一种在文件系统中实现更精细的访问控制的机制。它允许用户或组分配额外的权限给文件或目录。

- **设置 ACL 权限：**

  ```
  setfacl -m u:username:permissions file_or_directory
  setfacl -m g:groupname:permissions file_or_directory
  ```

- **查看 ACL 权限：**

  ```
  getfacl file_or_directory
  ```

### 2、**sudo 权限**（SuperUser Do）

`sudo`（SuperUser Do）是一个允许普通用户以超级用户的身份执行命令的工具。通过编辑 `/etc/sudoers` 文件，可以配置哪些用户或组可以以超级用户的权限运行特定命令。

- **编辑 sudoers 文件：**

  ```
  sudo visudo
  ```

- **为用户授予 sudo 权限：**

  ```
  username  ALL=(ALL:ALL) ALL
  ```

- **以 sudo 执行命令：**

  ```
  sudo command_to_run
  ```

### 3、**SUID 权限**（Set User ID）

SUID（Set User ID）是一种权限，允许在执行文件时暂时获得文件所有者的权限。通常用于需要以文件所有者的身份执行的可执行文件。

- 设置 SUID 权限：

  ```
  chmod u+s file
  ```

### 4、**SGID 权限**（Set Group ID）

SGID（Set Group ID）是一种权限，允许在执行文件时暂时获得文件组的权限。通常用于需要以文件组的身份执行的可执行文件。

- 设置 SGID 权限：

  ```
  chmod g+s file
  ```

### 5、**SBIT 权限**（Sticky Bit）

SBIT（Sticky Bit）是一种权限，通常用于目录，它防止用户删除其他用户在该目录中创建的文件。

- 设置 SBIT 权限：

  ```
  chmod +t directory
  ```